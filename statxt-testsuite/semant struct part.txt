
  (* Add struct name to symbol table *)
  let add_struct map sd = 
    let dup_err = "duplicate struct " ^ sd.sname
    and make_err er = raise (Failure er)
    and n = sd.sname (* Name of the struct *)
    in match sd with (* No duplicate structs*)
         _ when StringMap.mem n map -> make_err dup_err  
       | _ ->  StringMap.add n sd map 
  in
  (* Collect all struct names into one symbol table *)
  let struct_decls = List.fold_left add_struct StringMap.empty structs
  in
  (* Return a function from our symbol table *)
  let find_struct s = 
    try StringMap.find s struct_decls
    with Not_found -> raise (Failure ("unrecognized struct " ^ s))
  in

 (*) let check_struct struc =*)
    (* Make sure no members are void or duplicates *)
    (*let members' = check_binds "member" struc.members in*)

    (* Raise an exception if the given rvalue type cannot be assigned to
       the given lvalue type *)
   (* let check_assign lvaluet rvaluet err =
       if lvaluet = rvaluet then lvaluet else raise (Failure err)
    in   *)

    (* Build local symbol table of variables for this struct *)
  (* let symbols = List.fold_left (fun m (ty, name) -> StringMap.add name ty m)
                  StringMap.empty (members')
    in*)

    (* Return a variable from our local symbol table *)
    (*let type_of_identifier s =
      try StringMap.find s symbols
      with Not_found -> raise (Failure ("undeclared identifier " ^ s))
    in*)


    (* Return a semantically-checked expression, i.e., with a type *)
    (*let rec expr = function
        Intlit  l -> (Int, SIntlit l)
      | Fliteral l -> (Float, SFliteral l)
      | BoolLit l  -> (Bool, SBoolLit l)
      | Strlit l   -> (String, SStrlit l)
      | Charlit l  -> (Char, SCharlit l)
      | Noexpr     -> (Void, SNoexpr)

    in *)

   (* let structs' = List.map check_struct structs in *)